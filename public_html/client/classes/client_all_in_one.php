<?php
/*

    MERGED APPMONITOR CLIENT :: WORK IN PROGRESS

    generated Do 25 Nov 2021 15:45:27 CET

*/

 class checkApacheProcesses extends appmonitorcheck{ protected $_sServerStatusUrl = 'http://localhost/server-status'; protected $_iWarn = 50; protected $_iError = 75; protected function _getApacheProcesses() { $sBody = file_get_contents($this->_sServerStatusUrl); if(!$sBody){ return false; } $sRegexScoreboard = '/<pre>(.*)\<\/pre\>/U'; $aScore=array(); $sStatusNobr = str_replace("\n", "", $sBody); if (preg_match_all($sRegexScoreboard, $sStatusNobr, $aTmpTable)) { $sScoreString=$aTmpTable[1][0]; $aScore['total']=strlen($sScoreString); $aScore['free']=substr_count($sScoreString, '.'); $aScore['waiting']=substr_count($sScoreString, '_'); $aScore['active']=$aScore['total']-$aScore['free']-$aScore['waiting']; } return $aScore; } public function run($aParams){ if(isset($aParams['url']) && $aParams['url']){ $this->_sServerStatusUrl=$aParams['url']; } if(isset($aParams['warning']) && (int)$aParams['warning']){ $this->_iWarn=(int)$aParams['warning']; } if(isset($aParams['error']) && (int)$aParams['error']){ $this->_iError=(int)$aParams['error']; } $aProcesses=$this->_getApacheProcesses(); $iActive=$aProcesses ? $aProcesses['active'] : false; if($iActive===false){ $iResult=RESULT_UNKNOWN; } else { $sComment=''; $iTotal=$aProcesses['total']; $iResult=RESULT_OK; if(($iActive/$iTotal*100)>$this->_iWarn){ $iResult=RESULT_WARNING; $sComment='more than warning level '.$this->_iWarn.'%'; } else { $sComment='less than warning level '.$this->_iWarn.'%'; } if(($iActive/$iTotal*100)>$this->_iError){ $iResult=RESULT_ERROR; $sComment='more than error level '.$this->_iError.'%'; } } return array( $iResult, ($iActive===false ? 'Apache httpd server status is not available' : 'apache processes: '.print_r($aProcesses, 1)).' '.$sComment, ($iActive===false ? array() : array( 'type'=>'counter', 'count'=>$iActive, 'visual'=>'line', ) ) ); } } 
 class checkCert extends appmonitorcheck{ public function run($aParams) { $sUrl = isset($aParams["url"]) ? $aParams["url"] : 'http'. ($_SERVER['HTTPS'] ? 's' : '') . '://' . $_SERVER['SERVER_NAME'] .':' . $_SERVER['SERVER_PORT'] ; $bVerify = isset($aParams["verify"]) ? !!$aParams["verify"] : true; $iWarn = isset($aParams["warning"]) ? (int)($aParams["warning"]) : 30; $sMessage="Checked url: $sUrl ... "; $certinfo=$this->_certGetInfos($sUrl, $bVerify); if(isset($certinfo['_error'])){ return [ RESULT_ERROR, $certinfo['_error'] . $sMessage ]; } $sDNS=isset($certinfo['extensions']['subjectAltName']) ? $certinfo['extensions']['subjectAltName'] : false; $sHost=parse_url($sUrl,PHP_URL_HOST); if(strstr($sDNS, 'DNS:'.$sHost)===false){ return [ RESULT_ERROR, 'Wrong certificate: '.$sHost.' is not listed as DNS alias in ['.$sDNS.']  ' . $sMessage ]; } $iDaysleft = round(($certinfo['validTo_time_t'] - date('U')) / 60 / 60 / 24); $sMessage.= 'Issuer: '. $sIssuer=$certinfo['issuer']['O'] . '; valid from: '. date("Y-m-d H:i", $certinfo['validFrom_time_t']) . ' to '.date("Y-m-d H:i", $certinfo['validTo_time_t']).' ' . ( $iDaysleft ? "($iDaysleft days left)" : "expired since ".(-$iDaysleft)." days.") ; if ($iDaysleft<0) { return [ RESULT_ERROR, 'Expired! ' . $sMessage ]; } if ($iDaysleft<=$iWarn) { return [ RESULT_WARNING, 'Expires soon. ' . $sMessage ]; } return [ RESULT_OK, 'OK. ' .($bVerify ? 'Certificate is valid. ' : '(Verification is disabled; Check for expiration only.) ' ) . $sMessage ]; } } 
 class checkDiskfree extends appmonitorcheck{ public function run($aParams) { $this->_checkArrayKeys($aParams, "directory", "critical"); $sDirectory = $aParams["directory"]; if(!is_dir($sDirectory)){ return [ RESULT_ERROR, 'directory [' . $sDirectory . '] does not exist. Maybe it is wrong or is not mounted.' ]; } $iWarn = isset($aParams["warning"]) ? $this->_getSize($aParams["warning"]) : false; $iCritical = $this->_getSize($aParams["critical"]); $iSpaceLeft=disk_free_space($sDirectory); $sMessage='[' . $sDirectory . '] has '.$this->_getHrSize($iSpaceLeft).' left.'; if($iWarn){ if($iWarn<=$iCritical){ header('HTTP/1.0 503 Service Unavailable'); die("ERROR in a Diskfree check - warning value must be larger than critical.<pre>" . print_r($aParams, true)); } if ($iWarn<$iSpaceLeft){ return [ RESULT_OK, $sMessage.' Warning level is not reached yet (still '.$this->_getHrSize($iSpaceLeft-$iWarn).' over warning limit).' ]; } if ($iWarn>$iSpaceLeft && $iCritical<$iSpaceLeft){ return [ RESULT_WARNING, $sMessage.' Warning level '.$this->_getHrSize($iWarn).' was reached (space is '.$this->_getHrSize($iWarn-$iSpaceLeft).' below warning limit; still '.$this->_getHrSize($iSpaceLeft-$iCritical).' over critical limit).' ]; } } if ($iCritical<$iSpaceLeft){ return [RESULT_OK, $sMessage .' Minimum is not reached yet (still '.$this->_getHrSize($iSpaceLeft-$iCritical).' over critical limit).']; } else { return [RESULT_ERROR, $sMessage]; } } } 
 class checkFile extends appmonitorcheck{ public function run($aParams) { $aOK = array(); $aErrors = array(); $this->_checkArrayKeys($aParams, "filename"); $sFile = $aParams["filename"]; if (isset($aParams['exists'])) { $sMyflag = 'exists=' . ($aParams['exists'] ? 'yes' : 'no'); if (file_exists($sFile) && $aParams['exists']) { $aOK[] = $sMyflag; } else { $aErrors[] = $sMyflag; } } foreach (array('dir', 'executable', 'file', 'link', 'readable', 'writable') as $sFiletest) { if (isset($aParams[$sFiletest])) { $sTestCmd = 'return is_' . $sFiletest . '("' . $sFile . '");'; if (eval($sTestCmd) && $aParams[$sFiletest]) { $aOK[] = $sFiletest . '=' . ($aParams[$sFiletest] ? 'yes' : 'no'); } else { $aErrors[] = $sFiletest . '=' . ($aParams[$sFiletest] ? 'yes' : 'no'); } } } $sMessage = (count($aOK) ? ' flags OK: ' . implode('|', $aOK) : '') . ' ' . (count($aErrors) ? ' flags FAILED: ' . implode('|', $aErrors) : '') ; if (count($aErrors)) { return [ RESULT_ERROR, 'file test [' . $sFile . '] ' . $sMessage ]; } else { return[ RESULT_OK, 'file test [' . $sFile . '] ' . $sMessage ]; } } } 
 class checkHello extends appmonitorcheck{ public function run($aParams){ $this->_checkArrayKeys($aParams, "message"); return array( RESULT_OK, 'Hello world! My message is: ' .$aParams['message'] ); } } 
 class checkHttpContent extends appmonitorcheck{ public function run($aParams) { $this->_checkArrayKeys($aParams, "url"); if (!function_exists("curl_init")) { header('HTTP/1.0 503 Service Unavailable'); die("ERROR: PHP CURL module is not installed."); } $bShowContent = (isset($aParams["content"]) && $aParams["content"]) ? true : false; $ch = curl_init($aParams["url"]); curl_setopt($ch, CURLOPT_HEADER, 1); curl_setopt($ch, CURLOPT_NOBODY, isset($aParams["headeronly"]) && $aParams["headeronly"]); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, isset($aParams["follow"]) && $aParams["follow"]); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 0); curl_setopt($ch, CURLOPT_TIMEOUT, (isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp); $res = curl_exec($ch); if (!$res) { return [ RESULT_ERROR, 'ERROR: failed to fetch ' . $aParams["url"] . '.' ]; } $sOut=''; $bError=false; $aInfos = curl_getinfo($ch); curl_close($ch); $aTmp=explode("\r\n\r\n", $res, 2); $sHttpHeader=$aTmp[0]; $sHttpBody=isset($aTmp[1]) ? $aTmp[1] : false; $sOut.="Http status: ".$aInfos['http_code']." - "; if(isset($aParams["status"])){ if($aInfos['http_code'] === $aParams["status"]){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } else { if($aInfos['http_code'] >= 400){ $sOut.="Error page detected<br>"; $bError=true; } else { $sOut.="request successful<br>"; } } if(isset($aParams["headercontains"]) && $aParams["headercontains"]){ $sOut.="Http header contains &quot;".$aParams["headercontains"]."&quot; - "; if(!strstr($sHttpHeader, $aParams["headercontains"])===false){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } if(isset($aParams["headernotcontains"]) && $aParams["headernotcontains"]){ $sOut.="Http header does not contain &quot;".$aParams["headernotcontains"]."&quot; - "; if(strstr($sHttpHeader, $aParams["headernotcontains"])===false){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } if(isset($aParams["headerregex"]) && $aParams["headerregex"]){ $sOut.="Http header regex test &quot;".$aParams["headerregex"]."&quot; - "; try{ $bRegex=preg_match($aParams["headerregex"], $sHttpHeader); if($bRegex){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } catch(Exception $e){ $sOut.="Wrong REGEX<br>" . print_r($e, 1).'<br>'; $bError=true; } } if(isset($aParams["bodycontains"]) && $aParams["bodycontains"]){ $sOut.="Http body contains &quot;".$aParams["bodycontains"]."&quot; - "; if(!strstr($sHttpBody, $aParams["bodycontains"])===false){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } if(isset($aParams["bodynotcontains"]) && $aParams["bodynotcontains"]){ $sOut.="Http body does not contain &quot;".$aParams["bodynotcontains"]."&quot; - "; if(strstr($sHttpBody, $aParams["bodynotcontains"])===false){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } if(isset($aParams["bodyregex"]) && $aParams["bodyregex"]){ $sOut.="Http body regex test &quot;".$aParams["bodyregex"]."&quot; - "; try{ $bRegex=preg_match($aParams["bodyregex"], $sHttpBody); if($bRegex){ $sOut.="compare OK<br>"; } else { $sOut.="compare failed<br>"; $bError=true; } } catch(Exception $e){ $sOut.="Wrong REGEX<br>" . print_r($e, 1).'<br>'; $bError=true; } } if (!$bError) { return [ RESULT_OK, 'OK: http check "' . $aParams["url"] . '".<br>'.$sOut ]; } else { return [ RESULT_ERROR, 'ERROR: http check "' . $aParams["url"] . '".<br>'.$sOut ]; } } } 
 class checkLoadmeter extends appmonitorcheck{ protected function _getLoad() { if (function_exists('sys_getloadavg')){ $load = sys_getloadavg(); return $load[0]; } else { if(class_exists('COM')){ $wmi=new COM('WinMgmts:\\\\.'); $cpus=$wmi->InstancesOf('Win32_Processor'); $load=0; if(version_compare('4.50.0', PHP_VERSION) == 1){ while($cpu = $cpus->Next()){ $load += $cpu->LoadPercentage; } }else{ foreach($cpus as $cpu){ $load += $cpu->LoadPercentage; } } return $load; } return false; } } public function run($aParams){ $fLoad=$this->_getLoad(); if($fLoad===false){ $iResult=RESULT_UNKNOWN; } else { $iResult=RESULT_OK; if(isset($aParams['warning']) && $aParams['warning'] && $fLoad>$aParams['warning']){ $iResult=RESULT_WARNING; } if(isset($aParams['error']) && $aParams['error'] && $fLoad>$aParams['error']){ $iResult=RESULT_ERROR; } } return array( $iResult, ($fLoad===false ? 'load value is not available' : 'current load is: '.$fLoad), ($fLoad===false ? array() : array( 'type'=>'counter', 'count'=>$fLoad, 'visual'=>'line', ) ) ); } } 
 class checkMysqlConnect extends appmonitorcheck{ public function run($aParams) { $this->_checkArrayKeys($aParams, "server,user,password,db"); $mysqli=mysqli_init(); if(!$mysqli){ return [RESULT_ERROR, 'ERROR: mysqli_init failed.']; } if (!$mysqli->options(MYSQLI_OPT_CONNECT_TIMEOUT, (isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp)) { return [RESULT_ERROR, 'ERROR: setting mysqli_options failed.']; } $db = (isset($aParams["port"]) && $aParams["port"]) ? $mysqli->real_connect($aParams["server"], $aParams["user"], $aParams["password"], $aParams["db"], $aParams["port"]) : $mysqli->real_connect($aParams["server"], $aParams["user"], $aParams["password"], $aParams["db"]) ; if ($db) { $mysqli->close(); return [RESULT_OK, "OK: Mysql database " . $aParams["db"] . " was connected"]; return true; } else { return [ RESULT_ERROR, "ERROR: Mysql database " . $aParams["db"] . " was not connected. Error ".mysqli_connect_errno() .": ". mysqli_connect_error() ]; } } } 
 class checkPdoConnect extends appmonitorcheck{ public function run($aParams) { $this->_checkArrayKeys($aParams, "connect,user,password"); try{ $db = new PDO( $aParams['connect'], $aParams['user'], $aParams['password'], array( PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION, PDO::ATTR_TIMEOUT => (isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp, ) ); $db=null; return [RESULT_OK, "OK: Database was connected with PDO " . $aParams['connect']]; } catch(PDOException $e) { return [RESULT_ERROR, "ERROR: Database was not connected " . $aParams['connect'] . " was not connected. Error ".$e->getMessage()]; } } } 
 class checkPortTcp extends appmonitorcheck{ public function run($aParams) { $this->_checkArrayKeys($aParams, "port"); $sHost = array_key_exists('host', $aParams) ? $aParams['host'] : '127.0.0.1'; $iPort = (int) $aParams['port']; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); if ($socket === false) { return [RESULT_UNKNOWN, "ERROR: $sHost:$iPort was not checked. socket_create() failed: " . socket_strerror(socket_last_error())]; } socket_set_option( $socket, SOL_SOCKET, SO_SNDTIMEO, array( "sec"=>(isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp, "usec"=>0 ) ); $result = socket_connect($socket, $sHost, $iPort); if ($result === false) { socket_close($socket); return [RESULT_ERROR, "ERROR: $sHost:$iPort failed. " . socket_strerror(socket_last_error($socket))]; } else { socket_close($socket); return [RESULT_OK, "OK: $sHost:$iPort was connected."]; } } } 
 class checkSimple extends appmonitorcheck{ public function run($aParams) { $this->_checkArrayKeys($aParams, "result,value"); $aData=[]; foreach(array('type', 'count', 'visual') as $sMyKey){ if(isset($aParams[$sMyKey])){ $aData[$sMyKey]=$aParams[$sMyKey]; } } return [ $aParams["result"], $aParams["value"], count($aData) ? $aData : false ]; } } 
 class checkSqliteConnect extends appmonitorcheck{ public function run($aParams) { $this->_checkArrayKeys($aParams, "db"); if (!file_exists($aParams["db"])) { return [RESULT_ERROR, "ERROR: Sqlite database file " . $aParams["db"] . " does not exist."]; } if(!isset($aParams['user'])){ $aParams['user']=''; } if(!isset($aParams['password'])){ $aParams['password']=''; } try { $o = new PDO("sqlite:" . $aParams["db"], $aParams['user'], $aParams['password'], array( PDO::ATTR_TIMEOUT => (isset($aParams["timeout"]) && (int)$aParams["timeout"]) ? (int)$aParams["timeout"] : $this->_iTimeoutTcp, ) ); return [RESULT_OK, "OK: Sqlite database " . $aParams["db"] . " was connected"]; } catch (Exception $e) { return [RESULT_ERROR, "ERROR: Sqlite database " . $aParams["db"] . " was not connected. " . $e->getMessage()]; } } } 
 if(!defined('RESULT_OK')){ define("RESULT_OK", 0); define("RESULT_UNKNOWN", 1); define("RESULT_WARNING", 2); define("RESULT_ERROR", 3); } class appmonitorcheck { protected $_aConfig = array(); protected $_aData = array(); protected $_units = array( 'B', 'KB', 'MB', 'GB', 'TB'); protected $_iTimeoutTcp=5; protected $_sPluginDir=__DIR__.'/../plugins'; public function __construct() { } protected function _createDefaultMetadata() { $this->_aData = array( "name" => $this->_aConfig["name"], "description" => $this->_aConfig["description"], "result" => RESULT_UNKNOWN, "value" => false, "type" => false, "time" => false, ); return true; } protected function _setResult($iResult) { return $this->_aData["result"] = (int) $iResult; } protected function _setOutput($s) { return $this->_aData["value"] = (string) $s; } protected function _setCounter($aParams){ if(count($aParams)){ foreach(array('type', 'count', 'visual') as $sMyKey){ if(isset($aParams[$sMyKey])){ $this->_aData[$sMyKey]=$aParams[$sMyKey]; } } } return true; } protected function _setReturn($iResult, $s, $aCounter=array()) { $this->_setResult($iResult); $this->_setOutput($s); $this->_setCounter($aCounter); return true; } protected function _checkArrayKeys($aConfig, $sKeyList) { foreach (explode(",", $sKeyList) as $sKey) { if (!array_key_exists($sKey, $aConfig)) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' .__METHOD__ . " - array of check parameters requires the keys [$sKeyList] - but key <code>$sKey</code> was not found in config array." . "<pre>" . print_r($aConfig, true) .'</pre>' ); } if (is_null($aConfig[$sKey])) { header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' .__METHOD__ . " - key <code>$sKey</code> is empty in config array" . "<pre>" . print_r($aConfig, true) .'</pre>' ); } } return true; } public function makeCheck($aConfig) { $this->_iStart = microtime(true); $this->_checkArrayKeys($aConfig, "name,description,check"); $this->_checkArrayKeys($aConfig["check"], "function"); $this->_aConfig = $aConfig; $this->_createDefaultMetadata(); $sCheck = preg_replace('/[^a-zA-Z0-9]/', '', $this->_aConfig["check"]["function"]); $aParams = array_key_exists("params", $this->_aConfig["check"]) ? $this->_aConfig["check"]["params"] : array(); $sPluginFile=$this->_sPluginDir.'/checks/'.$sCheck.'.php'; $sCheckClass = 'check'.$sCheck; if (!class_exists($sCheckClass)){ if (file_exists($sPluginFile)) { } } if (!class_exists($sCheckClass)){ header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' .__METHOD__ . " - check class not found: <code>$sCheckClass</code>" . "<pre>" . print_r($aConfig, true) .'</pre>' ."<h2>Known checks</h2>\n".print_r($this->listChecks(), 1) ); } $oPlogin = new $sCheckClass; $aResponse=$oPlogin->run($aParams); if(!is_array($aResponse)){ header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' .__METHOD__ . " - plugin : $sCheck does not responses an array" . "<pre>INPUT " . print_r($aConfig, true) .'</pre>' . "<pre>RESPONSE " . print_r($aResponse, true) .'</pre>' ); } if(count($aResponse)<2){ header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' .__METHOD__ . " - plugin : $sCheck does not responses the minimum of 2 array values" . "<pre>INPUT " . print_r($aConfig, true) .'</pre>' . "<pre>RESPONSE " . print_r($aResponse, true) .'</pre>' ); } if(!isset($aResponse[2])){ $aResponse[2]=array(); } $this->_setReturn($aResponse[0], $aResponse[1], $aResponse[2]); $this->_aData['time'] = number_format((microtime(true) - $this->_iStart) * 1000, 3) . 'ms'; return $this->respond(); } public function listChecks() { $aReturn = array(); $class = new ReflectionClass($this); foreach ($class->getMethods(ReflectionMethod::IS_PROTECTED) as $oReflectionMethod) { if (strpos($oReflectionMethod->name, "check") === 0) { $aReturn[(string) $oReflectionMethod->name]=1; } } foreach(glob($this->_sPluginDir.'/checks/*.php') as $sPluginFile){ $aReturn[str_replace('.php', '', basename($sPluginFile))] = 1; } ksort($aReturn); return array_keys($aReturn); } public function respond() { return $this->_aData; } protected function _certGetInfos($sUrl, $bVerifyCert) { $iTimeout=10; $aUrldata=parse_url($sUrl); $sHost = isset($aUrldata['host']) ? $aUrldata['host'] : false; $iPort = isset($aUrldata['port']) ? $aUrldata['port'] : ((isset($aUrldata['scheme']) && $aUrldata['scheme'] === 'https') ? 443 : false); $aSsl=array('capture_peer_cert' => true); if($bVerifyCert){ $aSsl['verify_peer']=false; $aSsl['verify_peer_name']=false; }; $get = stream_context_create(array('ssl' => $aSsl)); if(!$get){ return array('_error' => 'Error: Cannot create stream_context'); } $errno=-1; $errstr="stream_socket_client failed."; $read = stream_socket_client("ssl://$sHost:$iPort", $errno, $errstr, $iTimeout, STREAM_CLIENT_CONNECT, $get); if(!$read){ return array('_error' => "Error $errno: $errstr; cannot create stream_socket_client with given stream_context to ssl://$sHost:$iPort; you can try to set the flag [verify] to false to check expiration date only."); } $cert = stream_context_get_params($read); if(!$cert){ return array('_error' => "Error: socket was connected to ssl://$sHost:$iPort - but I cannot read certificate infos with stream_context_get_params "); } $certinfo = openssl_x509_parse($cert['options']['ssl']['peer_certificate']); return $certinfo; } protected function _getHrSize($size){ $power = $size > 0 ? floor(log($size, 1024)) : 0; return number_format($size / pow(1024, $power), 2, '.', ',') . ' ' . $this->_units[$power]; } protected function _getSize($sValue){ if(is_int($sValue)){ return $sValue; } $power=0; foreach($this->_units as $sUnit){ if (preg_match('/^[0-9\.\ ]*'.$sUnit.'/', $sValue)){ $i=preg_replace('/([0-9\.]*).*/', '$1', $sValue); $iReal=$i*pow(1024, $power); return $iReal; } $power++; } header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' .__METHOD__ . " ERROR in space value parameter - there is no size unit in [$sValue] - allowed size units are " . implode('|', $this->_units) ); } protected function _compare($value, $sCompare, $verifyValue){ switch ($sCompare){ case "IS": return $value===$verifyValue; break; case "GE": return $value>=$verifyValue; break; case "GT": return $value>$verifyValue; break; case "HAS": return !!(strstr($value, $verifyValue)!==false); break; default: header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>' . '<h2>Details</h2>' .__METHOD__ . " - FATAL ERROR: a compare function [$sCompare] is not implemented (yet)." ); break; } return false; } } 
if (!class_exists('appmonitorcheck')){ } class appmonitor { protected $_sVersion = 'php-client-v0.93'; protected $_iDefaultTtl = 300; protected $_iMaxResult = false; protected $_aMeta = array(); protected $_aChecks = array(); protected $_iStart = false; public function __construct() { $this->_createDefaultMetadata(); } protected function _createDefaultMetadata() { $this->_iStart = microtime(true); $this->_aMeta = array( "host" => false, "website" => false, "ttl" => false, "result" => false, "time" => false, "version" => $this->_sVersion, ); $this->setHost(); $this->setWebsite(); $this->setTTL(); return true; } public function setHost($s = false) { if (!$s) { $s = php_uname("n"); } return $this->_aMeta["host"] = $s; } public function setWebsite($s = false) { if (!$s && isset($_SERVER["HTTP_HOST"])) { $s = $_SERVER["HTTP_HOST"]; } return $this->_aMeta["website"] = $s; } public function setTTL($iTTl = false) { if (!$iTTl) { $iTTl = $this->_iDefaultTtl; } return $this->_aMeta["ttl"] = $iTTl; } public function setResult($iResult = false) { if ($iResult === false) { $iResult = $this->_iMaxResult; } return $this->_aMeta["result"] = $iResult; } public function addCheck($aJob = array()) { $oCheck = new appmonitorcheck(); $aCheck = $oCheck->makecheck($aJob); $iMyResult=isset($aJob['worstresult']) ? min($aCheck["result"], $aJob['worstresult']) : $aCheck["result"] ; if (!$this->_iMaxResult || $iMyResult > $this->_iMaxResult) { $this->_iMaxResult = $iMyResult; } return $this->_aChecks[] = $aCheck; } protected function _addNotification($sType, $sValue, $sKey = false) { $sTypeCleaned = preg_replace('/[^a-z]/', '', strtolower($sType)); if (!isset($this->_aMeta['notifications'])) { $this->_aMeta['notifications'] = array(); } if (!isset($this->_aMeta['notifications'][$sTypeCleaned])) { $this->_aMeta['notifications'][$sTypeCleaned] = array(); } if ($sKey) { $this->_aMeta['notifications'][$sTypeCleaned][$sKey] = $sValue; } else { $this->_aMeta['notifications'][$sTypeCleaned][] = $sValue; } return true; } public function addEmail($sEmailAddress) { return $this->_addNotification('email', $sEmailAddress); } public function addSlackWebhook($sLabel, $sSlackWebhookUrl) { return $this->_addNotification('slack', $sSlackWebhookUrl, $sLabel); } public function addTag($sTag) { if(!isset($this->_aMeta['tags'])){ $this->_aMeta['tags']=array(); } $this->_aMeta['tags'][]=$sTag; return true; } public function checkIp($aAllowedIps = array()) { if (!isset($_SERVER['REMOTE_ADDR']) || !count($aAllowedIps)) { return true; } $sIP = $_SERVER['REMOTE_ADDR']; foreach ($aAllowedIps as $sIp2Check) { if (strpos($sIP, $sIp2Check) === 0) { return true; } } header('HTTP/1.0 403 Forbidden'); die('ERROR: Your ip address [' . $sIP . '] has no access.'); } public function checkToken($sVarname, $sToken) { if (!isset($_GET)) { return true; } if (isset($_GET[$sVarname]) && $_GET[$sVarname] === $sToken) { return true; } header('HTTP/1.0 403 Forbidden'); die('ERROR: A token is required.'); } public function listChecks() { $oCheck = new appmonitorcheck(); return $oCheck->listChecks(); } protected function _checkData() { $aErrors = array(); if (!count($this->_aChecks)) { $aErrors[] = "No checks have been defined."; } if ($this->_aMeta["result"] === false) { $aErrors[] = "method setResult was not used to set a final result for all checks."; } if (count($aErrors)) { $this->abort( '<h2>Error: client check is not complete</h2><p>Found errors:</p><ol><li>' . implode('<li>', $aErrors) . '</ol><br><br>' ); } return true; } public function abort($sMessage){ header('HTTP/1.0 503 Service Unavailable'); die('<h1>503 Service Unavailable</h1>'.$sMessage); } public function getResults() { return array( "meta" => $this->_aMeta, "checks" => $this->_aChecks, ); } public function render($bPretty = false, $bHighlight = false) { $this->_checkData(); $this->_aMeta['time'] = number_format((microtime(true) - $this->_iStart) * 1000, 3) . 'ms'; if (!defined('JSON_PRETTY_PRINT')) { $bPretty = false; } if (!$bPretty) { $bHighlight = false; $sOut = json_encode($this->getResults()); } else { $sOut = json_encode($this->getResults(), JSON_PRETTY_PRINT); if ($bHighlight) { $aMsg = array( 0 => "OK", 1 => "UNKNOWN", 2 => "WARNING", 3 => "ERROR" ); foreach (array_keys($aMsg) as $iCode) { $sOut = preg_replace('/(\"result\":\ ' . $iCode . ')/', '$1 <span class="result' . $iCode . '"> &lt;--- ' . $aMsg[$iCode] . ' </span>', $sOut); } $sOut = preg_replace('/:\ \"(.*)\"/U', ': "<span style="color:#66e;">$1</span>"', $sOut); $sOut = preg_replace('/:\ ([0-9]*)/', ': <span style="color:#3a3; font-weight: bold;">$1</span>', $sOut); $sOut = preg_replace('/\"(.*)\":/U', '"<span style="color:#840;">$1</span>":', $sOut); $sOut = preg_replace('/([{\[])/', '$1<blockquote>', $sOut); $sOut = preg_replace('/([}\]])/', '</blockquote>$1', $sOut); $sOut = str_replace('    ', '', $sOut); $sOut = '<!DOCTYPE html><html><head>' . '<style>' . 'body{background:#e0e8f8; color:#235; font-family: verdana,arial;}' . 'blockquote{background:rgba(0,0,0,0.03); border-left: 0px solid rgba(0,0,0,0.06); margin: 0 0 0 3em; padding: 0; border-radius: 1em; border-top-left-radius: 0;}' . 'blockquote blockquote:hover{; }' . 'blockquote blockquote blockquote:hover{border-color: #808;}' . 'pre{background:rgba(0,0,0,0.05); padding: 1em; border-radius: 1em;}' . '.result0{background:#aca; border-right: 0em solid #080;}' . '.result1{background:#666; border-right: 0em solid #ccc;}' . '.result2{background:#fc9; border-right: 0em solid #860;}' . '.result3{background:#800; border-right: 0em solid #f00;}' . '</style>' . '<title>' . __CLASS__ . '</title>' . '</head><body>' . '<h1>' . __CLASS__ . ' :: debug</h1>' . '<pre>' . $sOut . '</pre></body></html>'; } } if (!$bHighlight) { header('Content-type: application/json'); header('Cache-Control: cache'); header('max-age: ' . $this->_aMeta["ttl"]); } echo $sOut; return $sOut; } public function renderHtmloutput($sJson) { header('Content-type: text/html'); header('Cache-Control: cache'); header('max-age: ' . $this->_aMeta["ttl"]); $aMsg = array( 0 => "OK", 1 => "UNKNOWN", 2 => "WARNING", 3 => "ERROR" ); $aData= json_decode($sJson, 1); $sOut=''; $sOut.='<h2>Metadata</h2>' . '<div class="meta'.(isset($aData['meta']['result']) ? ' result'.$aData['meta']['result'] : '' ) .'">' . 'Status: ' . (isset($aData['meta']['result']) ? $aMsg[$aData['meta']['result']] : '?').'<br>' . '</div>' . 'Host: ' . (isset($aData['meta']['host']) ? '<span class="string">' . $aData['meta']['host'] .'</span>' : '?').'<br>' . 'Website: ' . (isset($aData['meta']['website']) ? '<span class="string">' . $aData['meta']['website'].'</span>' : '?').'<br>' . 'Execution time: ' . (isset($aData['meta']['time']) ? '<span class="float">' . $aData['meta']['time'] .'</span>' : '?').'<br>' .'<h2>Checks</h2>' ; if (isset($aData['checks'][0]) && count($aData['checks'])){ foreach($aData['checks'] as $aCheck){ $sOut.= '<span class="result'.$aCheck['result'].'"> <strong>'.$aCheck['name'].'</strong></span> <br>' . $aCheck['description'].'<br>' . $aCheck['value'].'<br>' . 'Execution time: ' . $aCheck['time'].'<br>' . 'Status: ' . $aMsg[$aCheck['result']].'<br>' . '<br>' ; } } $sOut.= '<hr>List of farbcodes: '; foreach ($aMsg as $i=>$sText){ $sOut.= '<span class="result'.$i.'">'. $sText.'</span> '; } $sOut = '<!DOCTYPE html><html><head>' . '<style>' . 'body{background:#fff; color:#444; font-family: verdana,arial; margin: 3em;}' . '.result0{background:#aca; border-left: 1em solid #080; padding: 0 0.5em; }' . '.result1{background:#ccc; border-left: 1em solid #aaa; padding: 0 0.5em; }' . '.result2{background:#fc9; border-left: 1em solid #860; padding: 0 0.5em; }' . '.result3{background:#f88; border-left: 1em solid #f00; padding: 0 0.5em; }' . '</style>' . '<title>' . __CLASS__ . '</title>' . '</head><body>' . '<h1>' . __CLASS__ . ' :: client status</h1>' . $sOut . '</body></html>'; echo $sOut; return $sOut; } } 